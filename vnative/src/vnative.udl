namespace vnative {
  u32 add(u32 a, u32 b);
  void tts_say_lang(string text, string path, string language);
  void tts_say(string text, string path);
  void play_mp3(string path);
  
};
interface Storage {
  constructor(string path);
  void stop();
  void set(string name, string value);
  string get(string name);
  void del(string name);
};

namespace crypto {
    /// Key pair generation for KEM (Kyber).
    ///
    /// Returns a list containing the public and private keys in hexadecimal format.
    fun kem_pair() -> list<string>;

    /// Encapsulates a shared secret using the recipient's public KEM key.
    ///
    /// * `public_key`: Recipient's public key in hexadecimal format.
    ///
    /// Returns a list containing the ciphertext and the shared secret in hexadecimal format.
    fun kem_encapsulate_public(public_key: string) -> list<string>;

    /// Decapsulates the shared secret using the recipient's private KEM key and the ciphertext.
    ///
    /// * `ciphertext`: Ciphertext in hexadecimal format.
    /// * `secret_key`: Recipient's private key in hexadecimal format.
    ///
    /// Returns the shared secret in hexadecimal format.
    fun kem_decapsulate_private(ciphertext: string, secret_key: string) -> string;

    /// Key pair generation for DSA (Digital Signature Algorithm).
    ///
    /// Returns a list containing the public and private keys in hexadecimal format.
    fun dsa_pair() -> list<string>;

    /// Signs a message using DSA.
    ///
    /// * `msg`: The message to be signed.
    /// * `public_key`: Signer's public key in hexadecimal format.
    /// * `secret_key`: Signer's private key in hexadecimal format.
    ///
    /// Returns the signature in hexadecimal format.
    fun dsa_sign(msg: string, public_key: string, secret_key: string) -> string;

    /// Verifies a DSA signature.
    ///
    /// * `msg`: The original message.
    /// * `sig`: The signature in hexadecimal format.
    /// * `public_key`: Signer's public key in hexadecimal format.
    ///
    /// Returns `true` if the signature is valid, `false` otherwise.
    fun dsa_verify(msg: string, sig: string, public_key: string) -> bool;

    /// Encodes text using Base64 (Standard alphabet).
    ///
    /// * `open_text`: The text to be encoded.
    ///
    /// Returns the Base64 encoded string.
    fun base64_encode(open_text: string) -> string;

    /// Decodes Base64 encoded text (Standard alphabet).
    ///
    /// * `ciphertext`: The Base64 encoded text.
    ///
    /// Returns the decoded string.
    fun base64_decode(ciphertext: string) -> string;

    /// Encrypts text using SHA512 hashing algorithm.
    ///
    /// * `open_text`: The text to be encrypted.
    ///
    /// Returns the SHA512 hash in hexadecimal format.
    fun sha512_encrypt(open_text: string) -> string;

    /// Encrypts text using SHA256 hashing algorithm.
    ///
    /// * `open_text`: The text to be encrypted.
    ///
    /// Returns the SHA256 hash in hexadecimal format.
    fun sha256_encrypt(open_text: string) -> string;

    /// Encrypts text using HMAC-SHA512 algorithm.
    ///
    /// * `open_text`: The text to be encrypted.
    /// * `code`: The secret code for HMAC.
    ///
    /// Returns the HMAC-SHA512 hash in hexadecimal format.
    fun hmac_encrypt(open_text: string, code: string) -> string;

    /// Verifies a HMAC-SHA512 hash.
    ///
    /// * `open_text`: The original text.
    /// * `mac`: The HMAC hash in hexadecimal format.
    /// * `code`: The secret code for HMAC.
    ///
    /// Returns `true` if the HMAC is valid, `false` otherwise.
    fun hmac_verify(open_text: string, mac: string, code: string) -> bool;

    /// Encrypts text using AES-256-GCM algorithm.
    ///
    /// * `plaintext`: The text to be encrypted.
    /// * `key_str`: The secret key string for AES encryption.
    ///
    /// Returns the AES-256-GCM ciphertext (including nonce) in hexadecimal format.
    fun aes_encrypt(plaintext: string, key_str: string) -> string;

    /// Decrypts AES-256-GCM encrypted text.
    ///
    /// * `encrypted_text`: The AES-256-GCM ciphertext (including nonce) in hexadecimal format.
    /// * `key_str`: The secret key string used for AES decryption.
    ///
    /// Returns the decrypted plaintext string.
    fun aes_decrypt(encrypted_text: string, key_str: string) -> string;

    /// Encrypts data into JWT (JSON Web Token) format.
    ///
    /// * `version`: JWT version string.
    /// * `data`: Data string to be included in JWT payload.
    /// * `secret`: Secret key string for JWT signing.
    ///
    /// Returns the JWT string.
    fun jwt_encrypt(version: string, data: string, secret: string) -> string;

    /// Verifies and decodes JWT (JSON Web Token).
    ///
    /// * `vwt`: JWT string to verify.
    /// * `secret`: Secret key string for JWT verification.
    ///
    /// Returns the decoded data string if JWT is valid, otherwise returns an empty string.
    fun jwt_verify(vwt: string, secret: string) -> string;
}